# -*- python -*-
# Copyright (c) 2012 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import os
Import('env')

if not env.Bit('linux'): Return()

# Android compiler cannot compile NDK C++ headers with these.
if not env.Bit('android'):
  env.Append(
      # TODO(cbiffle): give everyone else these warnings too.
      # TODO(karl): Why does -fno-rtti cause linking issues.
      # CXXFLAGS='-Weffc++ -Woverloaded-virtual -fno-rtti -fomit-frame-pointer',
      CXXFLAGS='-Weffc++ -Woverloaded-virtual -fomit-frame-pointer',
)

# ------------------------------------------------------------------
# Source generation is controlled by command line directives.
# The two directives are:
#   valclean : Delete the existing versions of the generated files.
#       This step should be done whenever ANY change may effect
#       the generated sources.
#
#   valgen : Regenerate any deleted source files. Note: some generated
#       source files do understand dependencies and do not need to be
#       deleted before calling valgen. However, do not count on this,
#       as some dependencies are not caught. To be safe, if you have
#       modified a file that effects source generation, run "valclean"
#       followed by a "valgen" to guarantee that generated sources are
#       up to date.
gen_env = env.Clone()

# Defines this source directory.
GEN_SRC_DIR = '${MAIN_DIR}/src/trusted/validator_arm/gen'

# The list of command line arguments to be passed to the code generators.
GEN_CL_ARGS=""

# The list of tables in armv7.table. From this, a separate source test
# file is generated for each table. This is done so that changes in the
# table result in localized changes in the test files, making it easier
# to see what has changed.
# TODO(karl): Find a way to generate this from file armv7.table.
GEN_TABLES = ["ARMv7",
              "data_processing_and_miscellaneous_instructions",
              "data_processing_register",
              "data_processing_register_shifted_register",
              "data_processing_immediate",
              "multiply_and_multiply_accumulate",
              "saturating_addition_and_subtraction",
              "halfword_multiply_and_multiply_accumulate",
              "extra_load_store_instructions",
              "synchronization_primitives",
              "msr_immediate_and_hints",
              "miscellaneous_instructions",
              "load_store_word_and_unsigned_byte",
              "load_store_word_and_unsigned_byte_str_or_push",
              "media_instructions",
              "parallel_addition_and_subtraction_signed",
              "parallel_addition_and_subtraction_unsigned",
              "packing_unpacking_saturation_and_reversal",
              "signed_multiply_signed_and_unsigned_divide",
              "branch_branch_with_link_and_block_data_transfer",
              "coprocessor_instructions_and_supervisor_call",
              "floating_point_data_processing_instructions",
              "other_floating_point_data_processing_instructions",
              "extension_register_load_store_instructions",
              "transfer_between_arm_core_and_extension_register_8_16_and_32_bit",
              "transfer_between_arm_core_and_extension_registers_64_bit",
              "unconditional_instructions",
              "memory_hints_advanced_simd_instructions_and_miscellaneous_instructions",
              "advanced_simd_data_processing_instructions",
              "simd_dp_3same",
              "simd_dp_3diff",
              "simd_dp_2scalar",
              "simd_dp_2shift",
              "simd_dp_2misc",
              "simd_dp_1imm",
              "advanced_simd_element_or_structure_load_store_instructions",
              ]

# The list of (NEON) tables that we have turned off. That is, no instructions
# in the corresponding table will be accepted by the NACL ARM validator.
# TODO(karl): Remove this list when NEON tables are ready.
TURNED_OFF_TABLES = []

# Changes table name to test name.
def _TableTestName(tbl):
  return 'arm32_decode_' + tbl + '_tests'

# Defines the full file name for a generated file.
def _gen_file(filename):
  return '%s/%s' % (GEN_SRC_DIR, filename)

# The set of generated test files.
GEN_TEST_LIST = [_TableTestName(x) + '.cc' for x in GEN_TABLES]

# Other files, besides test files, that are generated.
GEN_OTHER_LIST = ['arm32_decode.cc', 'arm32_decode.h',
                  'arm32_decode_named.cc' ,
                  'arm32_decode_named_classes.h',
                  'arm32_decode_named_decoder.h']

# Set of generated source files.
GEN_LIST = [_gen_file(x) for x in (GEN_TEST_LIST + GEN_OTHER_LIST)]

# Adds the (NEON) turned off tables to the list of generator command
# line arguments.
if TURNED_OFF_TABLES:
  GEN_CL_ARGS = GEN_CL_ARGS + ''.join(
      [' --table_remove=' + tbl for tbl in TURNED_OFF_TABLES])

generate = False
gen_env = env.Clone()
if 'valgen' in COMMAND_LINE_TARGETS: generate = True
if 'valclean' in COMMAND_LINE_TARGETS: generate = True

if generate:
  gen_env.AlwaysBuild(gen_env.Alias('valgen', GEN_LIST))
  gen_env.AlwaysBuild(
    gen_env.Alias('valclean', action=[Delete(x) for x in GEN_LIST]))

def _generate_source(filename, TABLE=None):
  table_arg = '--table=' + TABLE if TABLE else ''
  env.Command(target=_gen_file(filename),
              source=['armv7.table',
                      'generate_decoder.py',
                      'dgen_core.py',
                      'dgen_input.py',
                      'dgen_opt.py',
                      'dgen_output.py',
                      'dgen_add_patterns.py',
                      'dgen_decoder_output.py',
                      'dgen_test_output.py',
                      ],
              action=['${SOURCES[1].abspath} ${SOURCES[0].abspath} '
                      '${TARGET.abspath} Arm32DecoderState ' +
                       GEN_CL_ARGS + " " + table_arg])

for source in GEN_OTHER_LIST:
  _generate_source(source)

for tbl in GEN_TABLES:
  _generate_source(_TableTestName(tbl) + '.cc', tbl)

env.ComponentLibrary('arm_validator_core',
                     ['address_set.cc',
                      'actual_classes.cc',
                      'baseline_classes.cc',
                      'inst_classes.cc',
                      'model.cc',
                      'validator.cc',
                      'gen/arm32_decode.cc'])

env.ComponentLibrary('ncvalidate_arm_v2',
                     ['ncvalidate.cc'],
                     LIBS=['arm_validator_core',
                           '${OPTIONAL_COVERAGE_LIBS}'])

env.ComponentLibrary('arm_validator_reporters',
                     ['problem_reporter.cc'])

ncval = env.ComponentProgram(
    'arm-ncval-core',
    ['ncval.cc'],
    EXTRA_LIBS=['arm_validator_reporters',
                'arm_validator_core',
                env.NaClTargetArchSuffix('ncfileutils'),
                '${OPTIONAL_COVERAGE_LIBS}'])

env.SDKInstallBin('ncval', ncval, target='arm')

# Build test environment to show that we are compiling in the test
# environment (rather than for the TCB).
gtest_env = env.MakeGTestEnv()
gtest_env.Append(CCFLAGS=['-DNACL_TRUSTED_BUT_NOT_TCB'])

gtest_env.ComponentProgram('address_set_test_binary',
                           ['address_set_test.cc'],
                           EXTRA_LIBS=['arm_validator_core',
                                       '${OPTIONAL_COVERAGE_LIBS}'])

address_set_test = gtest_env.Command(target='address_set_test.out',
                                     source=['address_set_test_binary'],
                                     action=['${SOURCES[0].abspath}'])

# TODO(cbiffle): get this wrapped in QEMU.
#env.AddNodeToTestSuite(address_set_test, ['small_tests'], 'address_set_test')

validator_tests = {
  'test_external_jumps': 1,
  'test_forbidden_instructions': 1,
  'test_internal_jumps': 1,
  'test_sp_updates': 1,
  'test_stores': 1,
  # Removed test because these are simd vector stores.
  # TODO(karl): Turn back on when NEON tables are ready.
  # 'test_vector_stores': 1,
  'test_loads': 1,
  # Removed test because these are simd vector loads.
  # TODO(karl): Turn back on when NEON tables are ready.
  # 'test_vector_loads': 1,
}

for test, exit_status in validator_tests.iteritems():
  node = gtest_env.CommandTest(
      test + '_actual.out',
      [ncval, gtest_env.File('testdata/' + test + '.nexe')],
      exit_status = str(exit_status),
      filter_regex = "'^ncval'",
      # NOTE: all stdout_golden are currently empty
      stdout_golden = gtest_env.File('testdata/' + test + '.out'),
      stderr_golden = gtest_env.File('testdata/' + test + '.err'))

  gtest_env.AddNodeToTestSuite(node, ['small_tests', 'validator_tests'],
                               "run_arm_" + test)

gtest_env.ComponentLibrary('decoder_test_tools',
                           ['decoder_tester.cc',
                            'inst_classes_testers.cc',
                            'actual_vs_baseline.cc',
                            'named_class_decoder.cc',
                            'gen/arm32_decode_named.cc'])

gtest_env.ComponentLibrary('arm_validator_tester',
                           ['validator_tests.cc'])

# Do NOT name this program 'validator_tests' because this is the same name as
# a test suite, and scons will run that test suite if it ever builds
# a program of the same name.
validator_tests_exe = gtest_env.ComponentProgram(
                               'arm_validator_small_tests',
                               ['validator_small_tests.cc'],
                               EXTRA_LIBS=['arm_validator_tester',
                                           'arm_validator_core',
                                           'arm_validator_reporters'])

validator_small_test_node = gtest_env.CommandTest(
    'validator_small_tests.out',
    command=[validator_tests_exe])

gtest_env.AddNodeToTestSuite(validator_small_test_node,
    ['small_tests', 'validator_tests'],
    'run_arm_validator_small_tests')

validator_huge_tests_exe = gtest_env.ComponentProgram(
                               'arm_validator_huge_tests',
                               ['validator_huge_tests.cc'],
                               EXTRA_LIBS=['arm_validator_tester',
                                           'arm_validator_core',
                                           'arm_validator_reporters'])

validator_huge_test_node = gtest_env.CommandTest(
    'validator_huge_tests.out',
    command=[validator_huge_tests_exe],
    size='huge')

gtest_env.AddNodeToTestSuite(validator_huge_test_node,
    ['huge_tests', 'validator_tests'],
    'run_arm_validator_huge_tests')

# Test ARM (32-bit) instruction decoding.
for tbl in GEN_TABLES:
  # Note: We build the object file separately, to get around a scons
  # bug that (otherwise) puts the corresponding .o file in the
  # source gen directory.
  decoder_tests_obj = gtest_env.ComponentObject(
      _TableTestName(tbl) + '.o',
      _gen_file(_TableTestName(tbl) +'.cc'))

  decoder_tests_exe = gtest_env.ComponentProgram(
      'arm32_decode_' + tbl + '_tests',
      decoder_tests_obj,
      EXTRA_LIBS=['decoder_test_tools', 'arm_validator_core'])

  decoder_test_node = gtest_env.CommandTest(
      'arm32_decode_' + tbl + 'tests.out',
      command=[decoder_tests_exe],
      scale_timeout=1000)

  gtest_env.AddNodeToTestSuite(decoder_test_node,
                               ['huge_tests', 'arm_decoder_tests'],
                                'run_arm32_decode_' + tbl + '_tests')
